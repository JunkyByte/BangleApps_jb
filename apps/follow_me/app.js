function get_compass_image(){
  return require("heatshrink").decompress(atob("kEqwMB//+v////8n4DJ/EfAZPwh4DF8EHAZPAgYDJwA+BAYsAAYJOBAYn+AYN/AY/8AYM/AY0f/ADG+ADBh4DH8EBwEHKQIBCBoMH4AdBgfAFIIDBHIIVBJIOBwYDB4JxDQIefAYP5A="));
}

function get_bg_image(){
  return require("heatshrink").decompress(atob("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"));
}

function bigThenSmall(big, small, x, y) {
  g.setFont("7x11Numeric7Seg", 2);
  g.drawString(big, x, y);
  x += g.stringWidth(big);
  g.setFont("8x12");
  g.drawString(small, x, y);
}

function drawBattery() {
  bigThenSmall(E.getBattery(), "%", 130, 28);
}

function get_arrow_image(){
  return require("heatshrink").decompress(atob("jkywMB/4AE8ACB/kfAYOBAQPwAwP+gYGB4F///4h4GBDwXgn4aBg4GBwAatCAQXDDwYlCCIYYDD4QmDDl4RC4ICB/wjC/4A="));
}

function get_arrowg_image(){
  return require("heatshrink").decompress(atob("jky4MA///3HWBQXwAQMfAQMDAwV+AQMP8EAgP+AwM/4EAg/4AwP/DQQQBgf8AwN/wAaBEIIaoIwQGDgYNCj4UBgAbCg5fCn4pBgIwCDgd/DlQRCn4CBgIjCh4A=="));
}

function delta_angle(bearing, heading){
  return ((((bearing - heading) % 360) + 540) % 360) - 180
}

function norm(x){
  var s = 0;
  for (var i=0;i<x.length;i++){
    s+=x[i]*x[i];
  }
  return Math.sqrt(s)
}

function dot(a, b){
  var s = 0;
  for (let i=0;i<a.length;i++)
    s += a[i] * b[i];
  return s
}

function angular_dist(lat1, lon1, lat2, lon2){
  var deltaphi = radians(lat2 - lat1)
  var deltalambda = radians(lon2 - lon1)
  const a = Math.pow(Math.sin(deltaphi / 2), 2) +
            Math.cos(radians(lat1)) * Math.cos(radians(lat2)) *
            Math.pow(Math.sin(deltalambda /2), 2);
  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function bearing(lat1, lon1, lat2, lon2){
  var delta = radians(lon2-lon1);
  var alat = radians(lat1);
  var blat = radians(lat2);
  var y = Math.sin(delta) * Math.cos(blat);
  var x = Math.cos(alat)*Math.sin(blat) -
        Math.sin(alat)*Math.cos(blat)*Math.cos(delta);
  return Math.round(degrees(Math.atan2(y, x)));
}

function distance(lat1, lon1, lat2, lon2){  // Uses equirectangular approx
  var x = radians(lon1-lon2) * Math.cos(radians((lat1+lat2)/2));
  var y = radians(lat2-lat1);
  return Math.round(Math.sqrt(x*x + y*y) * 6371000);
}

function radians(a) {
  return a*Math.PI/180;
}

function degrees(a) {
  var d = a*180/Math.PI;
  return (d+360)%360;
}

function dist_segment(pos_lat, pos_lon, a_lat, a_lon, b_lat, b_lon){
  var d = distance(a_lat, a_lon, pos_lat, pos_lon);
  var alpha = (Math.abs(bearing(a_lat, a_lon, b_lat, b_lon) - bearing(a_lat, a_lon, pos_lat, pos_lon)) / 180) * Math.PI
  return Math.round(Math.abs(Math.sin(alpha) * d));
}

class Node {
  constructor(lat, lon, ele, time){
    this.lat = parseFloat(lat);
    this.lon = parseFloat(lon);
    this.ele = parseFloat(ele);
    this.time = parseFloat(time);
  }
}

class Route {
  constructor(route_json) {
    this.len = route_json.length;
    this.nodes = [];
    for (var idx in route_json) {
      var entry = route_json[idx];
      this.nodes.push(new Node(entry.lat, entry.lon, entry.ele, entry.time));
    }
  }

  get_node_idx(node) {
    for (var idx in this.nodes)
      if (this.nodes[idx] === node)
        return idx
    throw('Node not present');
  }
}

function indexOfSmallest(a) {
 var lowest = 0;
 for (var i = 1; i < a.length; i++) {
  if (a[i] < a[lowest]) lowest = i;
 }
 return lowest;
}

class Holder {
  constructor(route) {
    this.route = route;
    this.lat = undefined;
    this.log = undefined;
    this.ele = undefined;
    this.course = undefined;
    this._heading = undefined;
    this.speed = undefined;
    this.target_pos = undefined;
    this.pnode = undefined;
    this.nnode = undefined;
    this.dpnode = undefined;
    this.dnnode = undefined;
    this.dsegm = undefined;
    this.tot_length = undefined;
    this.inmenu = false;
    this.was_far = false;
    this.did_start = false;
    this.THR_FAR = 26;
    this.THR_CLOSE = 25;
  }

  get heading() {
    return mag.read(this._heading)
  }

  find_target() {  // https://stackoverflow.com/a/58883850/7063774
    // We set the target as a linear interpolation between the projection on segment and the current end point
    var delta12 = angular_dist(this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    var delta13 = angular_dist(this.pnode.lat, this.pnode.lon, this.lat, this.lon);
    var bear12 = bearing(this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    var bear13 = bearing(this.pnode.lat, this.pnode.lon, this.lat, this.lon);
    const ctangd = Math.asin(Math.sin(delta13) * Math.sin(bear13 - bear12));
    const atangd = Math.acos(Math.cos(delta13) / Math.cos(ctangd));
    // Calc intermediate point
    const a = Math.sin(delta12 - atangd) / Math.sin(delta12);
    const b = Math.sin(atangd) / Math.sin(delta12);
    const phi1 = radians(this.pnode.lat);
    const lam1 = radians(this.pnode.lon);
    const phi2 = radians(this.nnode.lat);
    const lam2 = radians(this.nnode.lon);
    const x = a * Math.cos(phi1) * Math.cos(lam1) + b * Math.cos(phi2) * Math.cos(lam2);
    const y = a * Math.cos(phi1) * Math.sin(lam1) + b * Math.cos(phi2) * Math.sin(lam2);
    const z = a * Math.sin(phi1) + b * Math.sin(phi2);
    const lat_p = degrees(Math.atan2(z, Math.sqrt(x*x + y*y)));
    const lon_p = degrees(Math.atan2(y, x));
    // Now linearly interpolate between end point and projected
    // The idea is: - on track -> end point - far from track -> projected point
    // console.log('ppoint: ' + this.pnode.lat + ' ' + this.pnode.lon);
    // console.log('npoint: ' + this.nnode.lat + ' ' + this.nnode.lon);
    // console.log('Proj point: ' + lat_p + ' ' + lon_p);
    // Dot between (current -> Projection) and (prev -> next)
    const curr_to_p = [this.nnode.lat - this.lat, this.nnode.lon - this.lon];
    const prev_to_next = [this.nnode.lat - this.pnode.lat, this.nnode.lon - this.pnode.lon];
    const c = Math.abs(dot(curr_to_p, prev_to_next)) / (norm(curr_to_p) * norm(prev_to_next)); // How correct wrt to segment
    console.log('cos betwen curr->proj and prev->next: ' + c);
    this.target_pos = [this.nnode.lat * (1 - c) + lat_p * c, this.nnode.lon * (1 - c) + lon_p * c];
    return this.target_pos
  }

  update_nodes() {
    // Update the nodes based on distance
    if (!this.was_far && this.dpnode > this.THR_FAR){
      console.log('[FAR PNODE] We are far from pnode, was_far=true');
      this.was_far = true;
    }
    
    if (!this.was_far)  // If we are too close to pnode just ignore
      return;

    // You close to nnode?
    if (this.dnnode < this.THR_CLOSE){
      console.log('[CLOSE NNODE] We are close to nnode, updating to next one');
      this.update_total_len();  // TODO
      // Update nodes p <- n and n <- n + 1
      var n_idx = route.get_node_idx(this.nnode);

      if (n_idx == this.route.len - 1){
        console.log('[LAST NODE] nnode is already last node');
        return
      }

      this.pnode = this.route.nodes[n_idx]
      this.nnode = this.route.nodes[n_idx + 1]
      this.was_far = false;
      return
    }

    // You close to pnode? (assuming we were far before)
    if (this.dpnode < this.THR_CLOSE){
      console.log('[CLOSE PNODE] We are close to previous node, updating backwards');
      // Update nodes n <- p and p <- p - 1
      this.update_total_len();  // TODO
      var p_idx = route.get_node_idx(this.pnode);

      if (p_idx == 0){
        console.log('[FIRST NODE] pnode is already first node');
        return
      }

      this.pnode = this.route.nodes[p_idx - 1]
      this.nnode = this.route.nodes[p_idx]
      this.was_far = false;
      return
    }
  }

  update_distances() {
    this.dsegm = dist_segment(this.lat, this.lon, this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    this.dpnode = distance(this.lat, this.lon, this.pnode.lat, this.pnode.lon);
    this.dnnode = distance(this.lat, this.lon, this.nnode.lat, this.nnode.lon);
  }

  update_total_len() {
    this.tot_length = 0;
    for (let idx = route.get_node_idx(holder.pnode); idx < this.route.len - 1; idx++){
      var pnode = this.route.nodes[idx];
      var nnode = this.route.nodes[idx + 1];
      this.tot_length += distance(pnode.lat, pnode.lon, nnode.lat, nnode.lon);
    }
  }

  find_endpoints() {  // Finds current endpoints assuming no previous information
    var distances = [];
    this.tot_length = 0;
    for (let idx = 0; idx < this.route.len; idx++){
      var node = this.route.nodes[idx];
      var d = distance(node.lat, node.lon, this.lat, this.lon);
      distances.push(d);
      this.tot_length += d;
      // console.log('d from node ' + idx + ': '+ distance(node.lat, node.lon, this.lat, this.lon))
    }

    // Greedy, find minimum distance, take 2 bef and 2 aft for segment calculation
    var min_idx = indexOfSmallest(distances);
    if (min_idx === 0){
      console.log('min idx is 0, increasing to 1')
      min_idx += 1
    }

    // Now distance to each segment
    var dist_segments = [];
    for (let i = -1; i < 2; i++) {  // TODO limit cases for min_idx
      var idx = i + min_idx;
      var pnode = this.route.nodes[idx];
      var nnode = this.route.nodes[idx + 1];
      dist_segments.push(dist_segment(this.lat, this.lon, pnode.lat, pnode.lon, nnode.lat, nnode.lon));
      console.log('d segm ' + idx + '->' + (idx + 1) + ' ' + dist_segments[dist_segments.length - 1]);
    }
    
    var min_segm_idx = indexOfSmallest(dist_segments);
    this.pnode = this.route.nodes[min_idx + min_segm_idx - 1];
    this.dpnode = distances[min_idx + min_segm_idx - 1]; 
    this.nnode = this.route.nodes[min_idx + min_segm_idx];
    this.dnnode = distances[min_idx + min_segm_idx]; 
    this.dsegm = dist_segments[min_segm_idx];
    console.log('picked ' +  (min_idx + min_segm_idx - 1) + '->' + (min_idx + min_segm_idx));
  }
}

var route_json = require("Storage").readJSON('og.json');
// var route_json = require("Storage").readJSON('prom_sirio.json');
var route = new Route(route_json);

var holder = new Holder(route);

// FAKE DATA
var route_trace_json = require("Storage").readJSON('trace.json');  // TODO
var route_trace = new Route(route_trace_json);
// route_trace = undefined;
//


/*
 * The idea is to always have the segment you belong to and the distances from both end points and the segment itself.
 * Given this information what you do is always show heading for following end point, if you are on track you
 * should be on the segment so this makes sense.
 * If you become too far from the segment itself the heading must become to the segment so that you can get back on track.
 * The heading should be given by both compass and gps direction, this should allow consistent tracking while you are moving
 * but also decent one when you are still. (maybe is better to have a linear interp between end point and segment so that
 * if you are on track it mostly is about end point, if you are far from track it leads you back to the segment)
 * The coordinates are in lat lon which makes everything a bit more complex
 * When to switch endpoint?
 * End point distance should decrease, when < THRESHOLD -> start point becomes end point and end point -> next end point
 * In case you go back we can do the opposite (take care after ^ you need to get far from start point before it can switch back)
 * to prevent jumps
 * TODO: Fallback if you dont get close enough to end point it should switch to following one if you progress anyway? I guess just manually recalculate
*/

function start(){
  // Start by finding end points
  holder.find_endpoints()
}

var nn = 0;
var tt = -1;
var nstep = 50;
function update(){
  // TODO load fake infos
  if (route_trace !== undefined){
    tt += 1;
    if (tt === nstep){
      nn += 1;
      tt = 0;
    }

    holder.lat = route_trace.nodes[nn].lat * (1 - tt/nstep) + route_trace.nodes[nn + 1].lat * tt/nstep
    holder.lon = route_trace.nodes[nn].lon * (1 - tt/nstep) + route_trace.nodes[nn + 1].lon * tt/nstep
    holder.ele = route_trace.nodes[nn].ele
    holder.speed = 0
    //
  }

  if (holder.heading === undefined || holder.lat === undefined){
    console.log(holder.heading + ' ' + holder.lat);
    E.showMessage('Sensors not ready')
    console.log('Sensors not ready');
    return
  }

  if (!holder.did_start){
    start();
    holder.did_start = true;
  }
  
  holder.update_nodes();
  holder.update_distances();
  holder.find_target();

  // TODO REMOVE
  console.log('Current fake pos: ' + nn + ' Lat ' + holder.lat + ' Lon ' + holder.lon);
  console.log('d pnode ' + holder.dpnode + ' d nnode ' + holder.dnnode + ' d segm ' + holder.dsegm);
}

function show_menu(){
  var mainmenu = {
    "" : {
      "title" : "Menu"
    },
    // "Calib. mag" : function() {  // TODO complex
    //   mag.docalibrate(true).then(() => {
    //     holder.inmenu = false;
    //     E.showMenu();
    //     draw();
    //   })},
    "Recalculate" : function() {E.showMenu(); holder.find_endpoints(); draw(true);},
    "Exit" : function() { E.showMenu(); holder.inmenu = false; draw(true);},
  };

  holder.inmenu = true;
  E.showMenu(mainmenu)
}


function draw(full){
  queueDraw();
  if (holder.inmenu){
    return
  }

  g.clear();  // Clear all
  g.drawImage(bg_image, 0, 0);

  if (full)
    draw_frequent(); // Redraw freq informations

  var r = [120, 21, 155, 58];
  g.clearRect(r[0], r[1], r[2], r[3]);
  g.setColor(bg_color[0], bg_color[1], bg_color[2]);
  g.fillRect(r[0], r[1], r[2], r[3]);

  g.setFont("7x11Numeric7Seg", 3);
  g.setColor(0, 0, 0);
  g.drawString(require("locale").time(new Date(), 1), 12, 23);

  g.setFont("8x12", 2);
  g.drawString((Math.round(holder.tot_length / 100) / 10).toFixed(1) + 'km', 65, 80); // distance to arrival

  if (holder.nnode !== undefined){
    console.log('nidx ' + route.get_node_idx(holder.nnode));
  }
}

function log_infos(){
  console.log('Lat ' + holder.lat);
  console.log('Lon ' + holder.lon);
  console.log('Alt ' + holder.alt);
  console.log('Course ' + holder.course);
  console.log('Head ' + holder.heading);
  console.log('Speed ' + holder.speed);
  console.log('dp ' + holder.dpnode);
  console.log('dn ' + holder.dnnode);
  console.log('ds ' + holder.dsegm);
}

function draw_frequent(){
  if (holder.inmenu){
    return
  }

  // Draw Compass
  var r = [118, 21, 156, 61];
  g.clearRect(r[0], r[1], r[2], r[3]);
  g.setColor(bg_color[0], bg_color[1], bg_color[2]);
  g.fillRect(r[0], r[1], r[2], r[3]);
  g.drawImage(get_compass_image(), 138, 40, {rotate: radians(holder.heading), scale: 0.75})

  // Draw arrows
  var delta = undefined;
  var b_target = undefined;
  if (holder.target_pos !== undefined){
    b_target = bearing(holder.lat, holder.lon, holder.target_pos[0], holder.target_pos[1]);
    delta = delta_angle(b_target, holder.heading);
    var w = undefined;
    var rot = undefined;

    var d = (Math.abs(delta) > 30);
    if (d && delta < 30){ // Right arrow
      w = 142;
      rot = 180;
    } else if (d && delta > -30) {
      w = 31;
      rot = 0;
    }

    var r1 = [135, 75, 145, 90];
    var r2 = [31, 75, 50, 90];
    g.setColor(bg_color[0], bg_color[1], bg_color[2]);
    g.clearRect(r1[0], r1[1], r1[2], r1[3]);
    g.fillRect(r1[0], r1[1], r1[2], r1[3]);
    g.clearRect(r2[0], r2[1], r2[2], r2[3]);
    g.fillRect(r2[0], r2[1], r2[2], r2[3]);
    g.drawImage(get_arrowg_image(), 31, 92, {rotate: 0});
    g.drawImage(get_arrowg_image(), 142, 92, {rotate: Math.PI});
    if (d){
      g.drawImage(get_arrow_image(), w, 92, {rotate: radians(rot)});
    }
  }
}

/* GPS event
{ "lat": number,      // Latitude in degrees
  "lon": number,      // Longitude in degrees
  "alt": number,      // altitude in M
  "speed": number,    // Speed in kph
  "course": number,   // Course in degrees
  "time": Date,       // Current Time (or undefined if not known)
  "satellites": 7,    // Number of satellites
  "fix": 1            // NMEA Fix state - 0 is no fix
  "hdop": number,     // Horizontal Dilution of Precision
}
*/
function onGPS(fix) {
  if (!fix.fix){
    return
  }

  holder.lat = fix.lat;
  holder.lon = fix.lon;
  holder.alt = fix.alt;  // TODO
  holder.speed = fix.speed;
  holder.course = fix.course;
}

var drawTimeout;
function queueDraw() {
  if (drawTimeout) clearTimeout(drawTimeout);
  drawTimeout = setTimeout(function() {
    drawTimeout = undefined;
    draw(true);
  }, 60000 - (Date.now() % 60000));
}

var bg_image = get_bg_image();
var bg_color = [0.917, 0.909, 0.803];
function main(){
  // Setup sensors and callbacks updating data
  require("Font7x11Numeric7Seg").add(Graphics);
  require("Font8x12").add(Graphics);
  Bangle.on('kill',function() {Bangle.setCompassPower(0, 'follow_me'); Bangle.setGPSPower(0, 'follow_me')});

  Bangle.on('mag', function(e) {holder._heading = e.heading});
  Bangle.on('GPS', onGPS);

  if (route_trace === undefined){ // TODO
    Bangle.setGPSPower(1, "follow_me");
  }

  Bangle.setCompassPower(1, "follow_me");
  update();
  draw();

  setInterval(function() {  // Every N seconds update internal infos and decide if you want to draw
    update();
  }, 10000);

  setInterval(function() {  // Every N seconds update internal infos and decide if you want to draw
    console.log('---- INFOS ----');
    log_infos();
    console.log('---------------');
  }, 5000);

  setTimeout(function() {
    setInterval(function() {  // Every N seconds update internal infos and decide if you want to draw
      draw_frequent();
    }, 500);
  }, 3000);
}

//
setWatch(() => {
  show_menu();
}, BTN1, {repeat:true});
var mag = require('magn_tilt');
if (!require("Storage").readJSON("magnav.json",1))
  mag.docalibrate(true).then(() => {
    main();
  });
else
  main();
