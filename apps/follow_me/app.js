function get_compass_image(){
  return require("heatshrink").decompress(atob("kEqwIEBgOAAYMD4ADJg/gAZMP+ADFj/4AZM//gDJv/+AY3/AYP/AYsBAYOAAY8DAYPAAY3gg4DGh4DB+ADHj/+v/4KQIBCBoP4n4dB/k/FIIDBHIIVBJIN+vgDBnxxDQIdgAYMGA"));
}

function get_bg_image(){
  return require("heatshrink").decompress(atob("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"));
}

function get_arrow_image(){
  return require("heatshrink").decompress(atob("jkywMB/4AE8ACB/kfAYOBAQPwAwP+gYGB4F///4h4GBDwXgn4aBg4GBwAatCAQXDDwYlCCIYYDD4QmDDl4RC4ICB/wjC/4A="));
}


function norm(x){
  var s = 0;
  for (var i=0;i<x.length;i++){
    s+=x[i]*x[i];
  }
  return Math.sqrt(s)
}

function dot(a, b){
  var s = 0;
  for (let i=0;i<a.length;i++)
    s += a[i] * b[i];
  return s
}

function angular_dist(lat1, lon1, lat2, lon2){
  var deltaphi = radians(lat2 - lat1)
  var deltalambda = radians(lon2 - lon1)
  const a = Math.pow(Math.sin(deltaphi / 2), 2) +
            Math.cos(radians(lat1)) * Math.cos(radians(lat2)) *
            Math.pow(Math.sin(deltalambda /2), 2);
  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function bearing(lat1, lon1, lat2, lon2){
  var delta = radians(lon2-lon1);
  var alat = radians(lat1);
  var blat = radians(lat2);
  var y = Math.sin(delta) * Math.cos(blat);
  var x = Math.cos(alat)*Math.sin(blat) -
        Math.sin(alat)*Math.cos(blat)*Math.cos(delta);
  return Math.round(degrees(Math.atan2(y, x)));
}

function distance(lat1, lon1, lat2, lon2){  // Uses equirectangular approx
  var x = radians(lon1-lon2) * Math.cos(radians((lat1+lat2)/2));
  var y = radians(lat2-lat1);
  return Math.round(Math.sqrt(x*x + y*y) * 6371000);
}

function radians(a) {
  return a*Math.PI/180;
}

function degrees(a) {
  var d = a*180/Math.PI;
  return (d+360)%360;
}

function dist_segment(pos_lat, pos_lon, a_lat, a_lon, b_lat, b_lon){
  var d = distance(a_lat, a_lon, pos_lat, pos_lon);
  var alpha = (Math.abs(bearing(a_lat, a_lon, b_lat, b_lon) - bearing(a_lat, a_lon, pos_lat, pos_lon)) / 180) * Math.PI
  return Math.round(Math.abs(Math.sin(alpha) * d));
}

class Node {
  constructor(lat, lon, ele, time){
    this.lat = parseFloat(lat);
    this.lon = parseFloat(lon);
    this.ele = parseFloat(ele);
    this.time = parseFloat(time);
  }
}

class Route {
  constructor(route_json) {
    this.len = route_json.length;
    this.nodes = [];
    for (var idx in route_json) {
      var entry = route_json[idx];
      this.nodes.push(new Node(entry.lat, entry.lon, entry.ele, entry.time));
    }
  }

  get_node_idx(node) {
    for (var idx in this.nodes)
      if (this.nodes[idx] === node)
        return idx
    throw('Node not present');
  }
}

function indexOfSmallest(a) {
 var lowest = 0;
 for (var i = 1; i < a.length; i++) {
  if (a[i] < a[lowest]) lowest = i;
 }
 return lowest;
}

class Holder {
  constructor(route) {
    this.route = route;
    this.lat = undefined;
    this.log = undefined;
    this.ele = undefined;
    this.course = undefined;
    this.heading = undefined;
    this.speed = undefined;
    this.target_pos = undefined;
    this.pnode = undefined;
    this.nnode = undefined;
    this.dpnode = undefined;
    this.dnnode = undefined;
    this.dsegm = undefined;
    this.tot_length = undefined;
    this.inmenu = false;
    this.was_far = false;
    this.did_start = false;
    this.THR_FAR = 26;
    this.THR_CLOSE = 25;
  }

  find_target() {  // https://stackoverflow.com/a/58883850/7063774
    // We set the target as a linear interpolation between the projection on segment and the current end point
    var delta12 = angular_dist(this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    var delta13 = angular_dist(this.pnode.lat, this.pnode.lon, this.lat, this.lon);
    var bear12 = bearing(this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    var bear13 = bearing(this.pnode.lat, this.pnode.lon, this.lat, this.lon);
    const ctangd = Math.asin(Math.sin(delta13) * Math.sin(bear13 - bear12));
    const atangd = Math.acos(Math.cos(delta13) / Math.cos(ctangd));
    // Calc intermediate point
    const a = Math.sin(delta12 - atangd) / Math.sin(delta12);
    const b = Math.sin(atangd) / Math.sin(delta12);
    const phi1 = radians(this.pnode.lat);
    const lam1 = radians(this.pnode.lon);
    const phi2 = radians(this.nnode.lat);
    const lam2 = radians(this.nnode.lon);
    const x = a * Math.cos(phi1) * Math.cos(lam1) + b * Math.cos(phi2) * Math.cos(lam2);
    const y = a * Math.cos(phi1) * Math.sin(lam1) + b * Math.cos(phi2) * Math.sin(lam2);
    const z = a * Math.sin(phi1) + b * Math.sin(phi2);
    const lat_p = degrees(Math.atan2(z, Math.sqrt(x*x + y*y)));
    const lon_p = degrees(Math.atan2(y, x));
    // Now linearly interpolate between end point and projected
    // The idea is: - on track -> end point - far from track -> projected point
    // console.log('ppoint: ' + this.pnode.lat + ' ' + this.pnode.lon);
    // console.log('npoint: ' + this.nnode.lat + ' ' + this.nnode.lon);
    // console.log('Proj point: ' + lat_p + ' ' + lon_p);
    // Dot between (current -> Projection) and (prev -> next)
    const curr_to_p = [this.nnode.lat - this.lat, this.nnode.lon - this.lon];
    const prev_to_next = [this.nnode.lat - this.pnode.lat, this.nnode.lon - this.pnode.lon];
    const c = Math.abs(dot(curr_to_p, prev_to_next)) / (norm(curr_to_p) * norm(prev_to_next)); // How correct wrt to segment
    console.log('cos betwen curr->proj and prev->next: ' + c);
    this.target_pos = [this.nnode.lat * (1 - c) + lat_p * c, this.nnode.lon * (1 - c) + lon_p * c];
    return this.target_pos
  }

  update_nodes() {
    // Update the nodes based on distance
    if (!this.was_far && this.dpnode > this.THR_FAR){
      console.log('[FAR PNODE] We are far from pnode, was_far=true');
      this.was_far = true;
    }
    
    if (!this.was_far)  // If we are too close to pnode just ignore
      return;

    // You close to nnode?
    if (this.dnnode < this.THR_CLOSE){
      console.log('[CLOSE NNODE] We are close to nnode, updating to next one');
      this.update_total_len();  // TODO
      // Update nodes p <- n and n <- n + 1
      var n_idx = route.get_node_idx(this.nnode);

      if (n_idx == this.route.len - 1){
        console.log('[LAST NODE] nnode is already last node');
        return
      }

      this.pnode = this.route.nodes[n_idx]
      this.nnode = this.route.nodes[n_idx + 1]
      this.was_far = false;
      return
    }

    // You close to pnode? (assuming we were far before)
    if (this.dpnode < this.THR_CLOSE){
      console.log('[CLOSE PNODE] We are close to previous node, updating backwards');
      // Update nodes n <- p and p <- p - 1
      this.update_total_len();  // TODO
      var p_idx = route.get_node_idx(this.pnode);

      if (p_idx == 0){
        console.log('[FIRST NODE] pnode is already first node');
        return
      }

      this.pnode = this.route.nodes[p_idx - 1]
      this.nnode = this.route.nodes[p_idx]
      this.was_far = false;
      return
    }
  }

  update_distances() {
    this.dsegm = dist_segment(this.lat, this.lon, this.pnode.lat, this.pnode.lon, this.nnode.lat, this.nnode.lon);
    this.dpnode = distance(this.lat, this.lon, this.pnode.lat, this.pnode.lon);
    this.dnnode = distance(this.lat, this.lon, this.nnode.lat, this.nnode.lon);
  }

  update_total_len() {
    this.tot_length = 0;
    for (let idx = route.get_node_idx(holder.pnode); idx < this.route.len - 1; idx++){
      var pnode = this.route.nodes[idx];
      var nnode = this.route.nodes[idx + 1];
      this.tot_length += distance(pnode.lat, pnode.lon, nnode.lat, nnode.lon);
    }
  }

  find_endpoints() {  // Finds current endpoints assuming no previous information
    var distances = [];
    this.tot_length = 0;
    for (let idx = 0; idx < this.route.len; idx++){
      var node = this.route.nodes[idx];
      var d = distance(node.lat, node.lon, this.lat, this.lon);
      distances.push(d);
      this.tot_length += d;
      // console.log('d from node ' + idx + ': '+ distance(node.lat, node.lon, this.lat, this.lon))
    }

    // Greedy, find minimum distance, take 2 bef and 2 aft for segment calculation
    var min_idx = indexOfSmallest(distances);
    if (min_idx === 0){
      console.log('min idx is 0, increasing to 1')
      min_idx += 1
    }

    // Now distance to each segment
    var dist_segments = [];
    for (let i = -1; i < 2; i++) {  // TODO limit cases for min_idx
      var idx = i + min_idx;
      var pnode = this.route.nodes[idx];
      var nnode = this.route.nodes[idx + 1];
      dist_segments.push(dist_segment(this.lat, this.lon, pnode.lat, pnode.lon, nnode.lat, nnode.lon));
      console.log('d segm ' + idx + '->' + (idx + 1) + ' ' + dist_segments[dist_segments.length - 1]);
    }
    
    var min_segm_idx = indexOfSmallest(dist_segments);
    this.pnode = this.route.nodes[min_idx + min_segm_idx - 1];
    this.dpnode = distances[min_idx + min_segm_idx - 1]; 
    this.nnode = this.route.nodes[min_idx + min_segm_idx];
    this.dnnode = distances[min_idx + min_segm_idx]; 
    this.dsegm = dist_segments[min_segm_idx];
    console.log('picked ' +  (min_idx + min_segm_idx - 1) + '->' + (min_idx + min_segm_idx));
  }
}

// var route_json = require("Storage").readJSON('og.json');
var route_json = require("Storage").readJSON('prom_sirio.json');
var route = new Route(route_json);

var holder = new Holder(route);

// FAKE DATA
var route_trace_json = require("Storage").readJSON('trace.json');  // TODO
var route_trace = new Route(route_trace_json);
route_trace = undefined;
//


/*
 * The idea is to always have the segment you belong to and the distances from both end points and the segment itself.
 * Given this information what you do is always show heading for following end point, if you are on track you
 * should be on the segment so this makes sense.
 * If you become too far from the segment itself the heading must become to the segment so that you can get back on track.
 * The heading should be given by both compass and gps direction, this should allow consistent tracking while you are moving
 * but also decent one when you are still. (maybe is better to have a linear interp between end point and segment so that
 * if you are on track it mostly is about end point, if you are far from track it leads you back to the segment)
 * The coordinates are in lat lon which makes everything a bit more complex
 * When to switch endpoint?
 * End point distance should decrease, when < THRESHOLD -> start point becomes end point and end point -> next end point
 * In case you go back we can do the opposite (take care after ^ you need to get far from start point before it can switch back)
 * to prevent jumps
 * TODO: Fallback if you dont get close enough to end point it should switch to following one if you progress anyway? I guess just manually recalculate
*/

function start(){
  // Start by finding end points
  holder.find_endpoints()
}

var nn = 0;
var tt = -1;
var nstep = 5;
function update(){
  // TODO load fake infos
  if (route_trace !== undefined){
    tt += 1;
    if (tt === nstep){
      nn += 1;
      tt = 0;
    }

    holder.lat = route_trace.nodes[nn].lat * (1 - tt/nstep) + route_trace.nodes[nn + 1].lat * tt/nstep
    holder.lon = route_trace.nodes[nn].lon * (1 - tt/nstep) + route_trace.nodes[nn + 1].lon * tt/nstep
    holder.ele = route_trace.nodes[nn].ele
    holder.speed = 0
    //
  }

  if (holder.heading === undefined || holder.lat === undefined){
    E.showMessage('Sensors not ready')
    console.log('Sensors not ready');
    return false
  }

  if (!holder.did_start){
    start();
    holder.did_start = true;
  }
  
  holder.update_nodes();
  holder.update_distances();
  holder.find_target();

  // TODO REMOVE
  console.log('Current fake pos: ' + nn + ' Lat ' + holder.lat + ' Lon ' + holder.lon);
  console.log('d pnode ' + holder.dpnode + ' d nnode ' + holder.dnnode + ' d segm ' + holder.dsegm);

  return true
}

function show_menu(){
  var mainmenu = {
    "" : {
      "title" : "Menu"
    },
    // "Calib. mag" : function() {  // TODO complex
    //   mag.docalibrate(true).then(() => {
    //     holder.inmenu = false;
    //     E.showMenu();
    //     draw();
    //   })},
    "Recalculate" : function() {E.showMenu(); holder.find_endpoints(); draw();},
    "Exit" : function() { E.showMenu(); holder.inmenu = false; draw();},
  };

  holder.inmenu = true;
  E.showMenu(mainmenu)
}


function draw(){
  if (holder.inmenu){
    return
  }

  g.clear();
  g.drawImage(bg_image, 0, 0);
  g.setFont("8x12", 2);
  g.setColor(0, 0, 0);
  g.drawString(require("locale").time(new Date(), 1), 65, 30);
  g.drawString((Math.round(holder.tot_length / 100) / 10).toFixed(1) + 'km', 93, 75); // distance to arrival

  var angle = undefined;
  if (holder.target_pos !== undefined){
    angle = bearing(holder.lat, holder.lon, holder.target_pos[0], holder.target_pos[1]) - 180;
    var w = undefined;
    var rot = undefined;
    if (angle > -90 && angle < 90){ // Right arrow
      w = 142;
      rot = 180;
    } else {
      w = 31;
      rot = 0;
    }
    g.drawImage(get_arrow_image(), w, 87, {rotate: radians(rot)});
  }

  console.log('angle ' + angle);
  console.log('Lat ' + holder.lat);
  console.log('Lon ' + holder.lon);
  console.log('Alt ' + holder.alt);
  console.log('Course ' + holder.course);
  console.log('Head ' + holder.heading);
  console.log('Speed ' + holder.speed);
  console.log('dp ' + holder.dpnode);
  console.log('dn ' + holder.dnnode);
  console.log('ds ' + holder.dsegm);

  if (holder.nnode !== undefined){
    console.log('nidx ' + route.get_node_idx(holder.nnode));
  }

  // Compass image
  g.drawImage(get_compass_image(), 125, 115, {rotate: radians(holder.heading)})
}

/* GPS event
{ "lat": number,      // Latitude in degrees
  "lon": number,      // Longitude in degrees
  "alt": number,      // altitude in M
  "speed": number,    // Speed in kph
  "course": number,   // Course in degrees
  "time": Date,       // Current Time (or undefined if not known)
  "satellites": 7,    // Number of satellites
  "fix": 1            // NMEA Fix state - 0 is no fix
  "hdop": number,     // Horizontal Dilution of Precision
}
*/
function onGPS(fix) {
  if (!fix.fix){
    return
  }

  holder.lat = fix.lat;
  holder.lon = fix.lon;
  holder.alt = fix.alt;  // TODO
  holder.speed = fix.speed;
  holder.course = fix.course;
}

var bg_image = get_bg_image();
function main(){
  // Setup sensors and callbacks updating data
  require("Font8x12").add(Graphics);
  Bangle.on('kill',function() {Bangle.setCompassPower(0); Bangle.setGPSPower(0)});
  // Bangle.setGPSPower(1, "follow_me");
  Bangle.setCompassPower(1, "follow_me");
  Bangle.on('mag', function(e) {holder.heading = Math.round(e.heading)});
  Bangle.on('gps', onGPS);

  update();
  draw();

  setInterval(function() {  // Every N seconds update internal infos and decide if you want to draw
    var shouldDraw = update();
    if (shouldDraw)
      draw();
  }, 5000);
}

//
setWatch(() => {
  show_menu();
}, BTN1, {repeat:true});
var mag = require('magn_tilt');
if (!require("Storage").readJSON("magnav.json",1))
  mag.docalibrate(true).then(() => {
    main();
  });
else
  main();
